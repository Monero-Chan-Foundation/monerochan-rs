use alloc::boxed::Box;

use p3_baby_bear::BabyBear;
use monerochan_stark::*;
use thiserror::Error;

pub mod internal;

use internal::{verify_monerochan_proof, verify_monerochan_reduce_proof, F, SC};

/// A reason why the verifier rejects a given proof.
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum CompressedError {
    #[error("failed to deserialize proof: {0}")]
    DeserializeProof(Box<bincode::ErrorKind>),
    #[error("unexpected proof mode: expected {exp:?}, got {0:?}", exp = MONEROCHANProofMode::Compressed)]
    Mode(MONEROCHANProofMode),
    #[error("failed to deserialize vkey hash: {0}")]
    DeserializeVkeyHash(Box<bincode::ErrorKind>),
    #[error("failed to verify proof: {0}")]
    ProofRejected(#[from] MachineVerificationError<SC>),
    #[error("single-shard proofs are currently unsupported by this verifier")]
    SingleShard,
    #[error("given public values do not match the commitment in the proof")]
    PublicValuesMismatch,
}

/// A verifier for MONEROCHAN "compressed" proofs.
#[derive(Debug)]
pub struct CompressedVerifier;
impl CompressedVerifier {
    /// Attempts to verify an MONEROCHAN "compressed" proof, as generated by the MONEROCHAN SDK.
    /// Returns `Ok` if the proof verifies or `Err` with the reason that verification failed.
    ///
    /// Due to technical limitations, this verifier rejects single-shard proofs, which roughly means
    /// proofs that come from very short programs. In this case, the verifier returns
    /// `Err(CompressedError::SingleShard)`.
    ///
    /// # Arguments
    ///
    /// * `proof` - The proof bytes.
    /// * `monerochan_vkey_hash` - The MONEROCHAN vkey hash.
    ///
    /// The arguments may be generated in the following manner:
    ///
    /// ```ignore
    /// use monerochan::{HashableKey, ProverClient, MONEROCHANProof};
    /// let client = ProverClient::builder().cpu().build();
    /// let (pk, vk) = client.setup(ELF);
    /// let monerochan_vkey_hash = bincode::serialize(&vk.hash_babybear()).unwrap();
    /// let proof: MONEROCHANProof = match client.prove(&pk, &stdin).compressed().run().unwrap().proof;
    /// ```
    pub fn verify_monerochan_proof(
        monerochan_proof: &[u8],
        monerochan_public_inputs: &[u8],
        monerochan_vkey_hash: &[u8],
    ) -> Result<(), CompressedError> {
        let monerochan_proof: MONEROCHANProof =
            bincode::deserialize(monerochan_proof).map_err(CompressedError::DeserializeProof)?;
        let vkey_hash: [F; 8] = deserialize_vkey(monerochan_vkey_hash)?;

        verify_monerochan_proof(&monerochan_proof, monerochan_public_inputs, &vkey_hash)?;

        Ok(())
    }
    pub fn verify_monerochan_reduce_proof(
        monerochan_reduce_proof: &[u8],
        monerochan_public_inputs: &[u8],
        monerochan_vkey_hash: &[u8],
    ) -> Result<(), CompressedError> {
        let reduce_proof: Box<MONEROCHANReduceProof<SC>> =
            bincode::deserialize(monerochan_reduce_proof).map_err(CompressedError::DeserializeProof)?;
        let vkey_hash: [F; 8] = deserialize_vkey(monerochan_vkey_hash)?;

        verify_monerochan_reduce_proof(reduce_proof.as_ref(), monerochan_public_inputs, &vkey_hash)?;

        Ok(())
    }
}

fn deserialize_vkey(monerochan_vkey_hash: &[u8]) -> Result<[BabyBear; 8], CompressedError> {
    bincode::deserialize(monerochan_vkey_hash).map_err(CompressedError::DeserializeVkeyHash)
}
